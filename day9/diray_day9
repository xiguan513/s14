进程 线程 协程
http://www.cnblogs.com/alex3714/articles/5230609.html
进程  空间资源的集合，至少有个线程
线程  实际的运行单位

主线程
子线程
    默认情况下，主线程执行完毕后，会等待子线程执行完成以后，在退出程序

守护线程: 配置守护线程后，主线程执行完毕，不管子线程是否执行完，直接退出

python线程直接调用操作系统原生线程
默认python同一时间只运行一个线程，不管是否是多线程


cpython 通过c语言实现的会有这种问题
全局解释器锁：
    针对多颗CPU的情况下，python多线程可以调用多颗CPU执行任务，但是实际上同一时间内只有一颗CPU在执行任务，
    只有等待某一颗CPU线程任务执行结束以后，才会执行其他CPU线程任务，

jpython 通过java语言实现的

pypy

用户级别锁：（互斥锁）
    lock=threading.Lock()
    lock.acquire()申请锁
    lock.release()释放锁
    注意：python3 中已经优化自动加锁和解锁不需要单独创建用户级别锁


递归锁
    lock=threading.RLock()

信号量（多把锁）


进程池


event(事件)

event=threading.event()
event.set() 设置
event.wait() 等待
event.clear() 清空


queue队列
MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。
MQ是消费-生产者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取或者订阅队列中的消息。
queue.Queue先入先出
queue.LifoQueue后入先出
queue.PriorityQueue存储数据时可以设置优先级的队列

q=queue.Queue()
q.get()取出数据，数据
q.put()存入数据
q.get_nowait()如果没有数据报错
q.qsize()


生产者消费者模型


paramiko 模块
http://www.cnblogs.com/wupeiqi/articles/5095821.html